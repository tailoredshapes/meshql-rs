"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.MetadataExtractionProcessor=exports.JsonParsingEngine=void 0;var jsiiDeprecationWarnings=()=>{var tmp=require("../../../.warnings.jsii.js");return jsiiDeprecationWarnings=()=>tmp,tmp};const JSII_RTTI_SYMBOL_1=Symbol.for("jsii.rtti");var core_1=()=>{var tmp=require("../../../core");return core_1=()=>tmp,tmp};class JsonParsingEngine{parsingEngine;static[JSII_RTTI_SYMBOL_1]={fqn:"aws-cdk-lib.aws_kinesisfirehose.JsonParsingEngine",version:"2.239.0"};static JQ_1_6=JsonParsingEngine.of("JQ-1.6");static of(parsingEngine){return new JsonParsingEngine(parsingEngine)}constructor(parsingEngine){this.parsingEngine=parsingEngine}}exports.JsonParsingEngine=JsonParsingEngine;class MetadataExtractionProcessor{options;keys;static[JSII_RTTI_SYMBOL_1]={fqn:"aws-cdk-lib.aws_kinesisfirehose.MetadataExtractionProcessor",version:"2.239.0"};static jq16(query){const keys=Object.keys(query);if(keys.length===0)throw new(core_1()).UnscopedValidationError("The query for MetadataExtractionProcessor should not be empty.");if(keys.length>50)throw new(core_1()).UnscopedValidationError("The query for MetadataExtractionProcessor cannot exceed the limit of 50 keys.");const jqQuery=keys.map(key=>`${JSON.stringify(key)}:${query[key]}`),options={jsonParsingEngine:JsonParsingEngine.JQ_1_6,metadataExtractionQuery:`{${jqQuery.join(",")}}`};return new MetadataExtractionProcessor(options,keys)}props={};constructor(options,keys){this.options=options,this.keys=keys;try{jsiiDeprecationWarnings().aws_cdk_lib_aws_kinesisfirehose_MetadataExtractionProcessorOptions(options)}catch(error){throw process.env.JSII_DEBUG!=="1"&&error.name==="DeprecationError"&&Error.captureStackTrace(error,MetadataExtractionProcessor),error}}bind(scope,options){try{jsiiDeprecationWarnings().aws_cdk_lib_aws_kinesisfirehose_DataProcessorBindOptions(options)}catch(error){throw process.env.JSII_DEBUG!=="1"&&error.name==="DeprecationError"&&Error.captureStackTrace(error,this.bind),error}if(!options.dynamicPartitioningEnabled)throw new(core_1()).ValidationError("MetadataExtractionProcessor can only be present when Dynamic Partitioning is enabled.",scope);const re=/!\{partitionKeyFromQuery:([^{}]+)\}/g,usedKeys=new Set;let match;for(;match=re.exec(options.prefix??"");)usedKeys.add(match[1]);if(!(this.keys.length===usedKeys.size&&this.keys.every(key=>usedKeys.has(key))))throw new(core_1()).ValidationError("When dynamic partitioning via inline parsing is enabled, you must use all specified dynamic partitioning key values for partitioning your data source.",scope);const parameters=[{parameterName:"MetadataExtractionQuery",parameterValue:this.options.metadataExtractionQuery},{parameterName:"JsonParsingEngine",parameterValue:this.options.jsonParsingEngine.parsingEngine}];return{processorType:"MetadataExtraction",processorIdentifier:{parameterName:"",parameterValue:""},parameters}}}exports.MetadataExtractionProcessor=MetadataExtractionProcessor;
