"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Manifest = exports.VERSION_MISMATCH = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const fs = require("fs");
const jsonschema = require("jsonschema");
const semver = require("semver");
const assembly = require("./cloud-assembly");
/* eslint-disable @typescript-eslint/no-var-requires */
/* eslint-disable @typescript-eslint/no-require-imports */
// this prefix is used by the CLI to identify this specific error.
// in which case we want to instruct the user to upgrade his CLI.
// see exec.ts#createAssembly
exports.VERSION_MISMATCH = 'Cloud assembly schema version mismatch';
/**
 * CLI version is created at build and release time
 *
 * It needs to be .gitignore'd, otherwise the projen 'no uncommitted
 * changes' self-check will fail, which means it needs to be generated
 * at build time if it doesn't already exist.
 */
const CLI_VERSION = require("../cli-version.json");
const ASSETS_SCHEMA = require("../schema/assets.schema.json");
const ASSEMBLY_SCHEMA = require("../schema/cloud-assembly.schema.json");
const INTEG_SCHEMA = require("../schema/integ.schema.json");
/**
 * Version is shared for both manifests
 */
const SCHEMA_VERSION = require("../schema/version.json");
/**
 * Protocol utility class.
 */
class Manifest {
    /**
     * Validates and saves the cloud assembly manifest to file.
     *
     * @param manifest - manifest.
     * @param filePath - output file path.
     */
    static saveAssemblyManifest(manifest, filePath) {
        Manifest.saveManifest(manifest, filePath, ASSEMBLY_SCHEMA);
    }
    /**
     * Load and validates the cloud assembly manifest from file.
     *
     * @param filePath - path to the manifest file.
     */
    static loadAssemblyManifest(filePath, options) {
        return Manifest.loadManifest(filePath, ASSEMBLY_SCHEMA, Manifest.patchStackTagsOnRead, options);
    }
    /**
     * Validates and saves the asset manifest to file.
     *
     * @param manifest - manifest.
     * @param filePath - output file path.
     */
    static saveAssetManifest(manifest, filePath) {
        Manifest.saveManifest(manifest, filePath, ASSETS_SCHEMA);
    }
    /**
     * Load and validates the asset manifest from file.
     *
     * @param filePath - path to the manifest file.
     */
    static loadAssetManifest(filePath) {
        return Manifest.loadManifest(filePath, ASSETS_SCHEMA);
    }
    /**
     * Validates and saves the integ manifest to file.
     *
     * @param manifest - manifest.
     * @param filePath - output file path.
     */
    static saveIntegManifest(manifest, filePath) {
        Manifest.saveManifest(manifest, filePath, INTEG_SCHEMA);
    }
    /**
     * Load and validates the integ manifest from file.
     *
     * @param filePath - path to the manifest file.
     */
    static loadIntegManifest(filePath) {
        const manifest = this.loadManifest(filePath, INTEG_SCHEMA);
        // Adding typing to `validate()` led to `loadManifest()` to properly infer
        // its return type, which indicated that the return type of this
        // function may be a lie. I could change the schema to make `testCases`
        // optional, but that will bump the major version of this package and I
        // don't want to do that. So instead, just make sure `testCases` is always there.
        return {
            ...manifest,
            testCases: manifest.testCases ?? [],
        };
    }
    /**
     * Fetch the current schema version number.
     */
    static version() {
        return `${SCHEMA_VERSION.revision}.0.0`;
    }
    /**
     * Return the CLI version that supports this Cloud Assembly Schema version
     */
    static cliVersion() {
        const version = CLI_VERSION.version;
        return version ? version : undefined;
    }
    /**
     * Deprecated
     * @deprecated use `saveAssemblyManifest()`
     */
    static save(manifest, filePath) {
        return this.saveAssemblyManifest(manifest, filePath);
    }
    /**
     * Deprecated
     * @deprecated use `loadAssemblyManifest()`
     */
    static load(filePath) {
        return this.loadAssemblyManifest(filePath);
    }
    static validate(manifest, schema, options) {
        function parseVersion(version) {
            const ver = semver.valid(version);
            if (!ver) {
                throw new Error(`Invalid semver string: "${version}"`);
            }
            return ver;
        }
        const maxSupported = semver.major(parseVersion(Manifest.version()));
        const actual = parseVersion(manifest.version);
        // first validate the version should be accepted. all versions within the same minor version are fine
        if (maxSupported < semver.major(actual) && !options?.skipVersionCheck) {
            // If we have a more specific error to throw than the generic one below, make sure to add that info.
            const cliVersion = manifest.minimumCliVersion;
            let cliWarning = '';
            if (cliVersion) {
                cliWarning = `. You need at least CLI version ${cliVersion} to read this manifest.`;
            }
            // we use a well known error prefix so that the CLI can identify this specific error
            // and print some more context to the user.
            throw new Error(`${exports.VERSION_MISMATCH}: Maximum schema version supported is ${maxSupported}.x.x, but found ${actual}${cliWarning}`);
        }
        // now validate the format is good.
        const validator = new jsonschema.Validator();
        const result = validator.validate(manifest, schema, {
            // does exist but is not in the TypeScript definitions
            nestedErrors: true,
            allowUnknownAttributes: false,
            preValidateProperty: Manifest.validateAssumeRoleAdditionalOptions,
        });
        let errors = result.errors;
        if (options?.skipEnumCheck) {
            // Enum validations aren't useful when
            errors = stripEnumErrors(errors);
        }
        if (errors.length > 0) {
            throw new Error(`Invalid assembly manifest:\n${errors.map((e) => e.stack).join('\n')}`);
        }
    }
    static saveManifest(manifest, filePath, schema, preprocess) {
        let withVersion = {
            ...manifest,
            version: Manifest.version(),
            minimumCliVersion: Manifest.cliVersion(),
        };
        Manifest.validate(withVersion, schema);
        if (preprocess) {
            withVersion = preprocess(withVersion);
        }
        fs.writeFileSync(filePath, JSON.stringify(withVersion, undefined, 2));
    }
    static loadManifest(filePath, schema, preprocess, options) {
        const contents = fs.readFileSync(filePath, { encoding: 'utf-8' });
        let obj;
        try {
            obj = JSON.parse(contents);
        }
        catch (e) {
            throw new Error(`${e.message}, while parsing ${JSON.stringify(contents)}`);
        }
        if (preprocess) {
            obj = preprocess(obj);
        }
        Manifest.validate(obj, schema, options);
        return obj;
    }
    /**
     * Fix the casing of stack tags entries
     *
     * At the very beginning of the CDK we used to emit stack tags as an object with
     * `{ Key, Value }` keys; this had the "advantage" that we could stick those
     * tags directly into the `CreateChangeSet` call.
     *
     * Then we later on used jsii on the assembly schema and we were forced to type
     * the in-memory objects as `{ key, value }` with lowercase letters. Now the
     * objects have a different on-disk and in-memory format, and we need to convert
     * between them.
     *
     * For backwards compatibility reasons, we used to convert lowercase in-memory
     * to uppercase on-disk variant until very recently. This is now unnecessary,
     * since no officially supported CDK tools read the stack tags from the
     * metadata; the CLI and toolkit library read stack tags from the artifact
     * properties.
     *
     * So although we don't emit uppercase stack tag objects anymore, we might still read
     * manifests that have them. Because the manifest we read must pass JSON Schema
     * validation (which expects lowercase tag objects), we have to fix the casing
     * of these objects after reading from disk and before validating.
     *
     * That's what this function does.
     */
    static patchStackTagsOnRead(manifest) {
        const artifacts = Object.values(manifest.artifacts ?? {})
            .filter(artifact => artifact.type === assembly.ArtifactType.AWS_CLOUDFORMATION_STACK);
        for (const artifact of artifacts) {
            const tagMetadata = Object.values(artifact.metadata ?? {})
                .flatMap(x => x)
                .filter(entry => entry.type === assembly.ArtifactMetadataEntryType.STACK_TAGS);
            for (const entry of tagMetadata) {
                const tags = entry.data;
                for (const tag of tags ?? []) {
                    const t = tag;
                    if ('Key' in t) {
                        t.key = t.Key;
                        delete t.Key;
                    }
                    if ('Value' in t) {
                        t.value = t.Value;
                        delete t.Value;
                    }
                }
            }
        }
        return manifest;
    }
    /**
     * Validates that `assumeRoleAdditionalOptions` doesn't contain nor `ExternalId` neither `RoleArn`, as they
     * should have dedicated properties preceding this (e.g `assumeRoleArn` and `assumeRoleExternalId`).
     */
    static validateAssumeRoleAdditionalOptions(instance, key, _schema, _options, _ctx) {
        if (key !== 'assumeRoleAdditionalOptions') {
            // note that this means that if we happen to have a property named like this, but that
            // does want to allow 'RoleArn' or 'ExternalId', this code will have to change to consider the full schema path.
            // I decided to make this less granular for now on purpose because it fits our needs and avoids having messy
            // validation logic due to various schema paths.
            return;
        }
        const assumeRoleOptions = instance[key];
        if (assumeRoleOptions?.RoleArn) {
            throw new Error(`RoleArn is not allowed inside '${key}'`);
        }
        if (assumeRoleOptions?.ExternalId) {
            throw new Error(`ExternalId is not allowed inside '${key}'`);
        }
    }
}
exports.Manifest = Manifest;
_a = JSII_RTTI_SYMBOL_1;
Manifest[_a] = { fqn: "@aws-cdk/cloud-assembly-schema.Manifest", version: "50.4.0" };
function stripEnumErrors(errors) {
    return errors.filter((e) => typeof e.schema === 'string' || !('enum' in e.schema));
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFuaWZlc3QuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJtYW5pZmVzdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLHlCQUF5QjtBQUN6Qix5Q0FBeUM7QUFDekMsaUNBQWlDO0FBRWpDLDZDQUE2QztBQUc3Qyx1REFBdUQ7QUFDdkQsMERBQTBEO0FBRTFELGtFQUFrRTtBQUNsRSxpRUFBaUU7QUFDakUsNkJBQTZCO0FBQ2hCLFFBQUEsZ0JBQWdCLEdBQVcsd0NBQXdDLENBQUM7QUFFakY7Ozs7OztHQU1HO0FBQ0gsbURBQW9EO0FBRXBELDhEQUErRDtBQUUvRCx3RUFBeUU7QUFFekUsNERBQTZEO0FBRTdEOztHQUVHO0FBQ0gseURBQTBEO0FBc0MxRDs7R0FFRztBQUNILE1BQXNCLFFBQVE7SUFDNUI7Ozs7O09BS0c7SUFDSSxNQUFNLENBQUMsb0JBQW9CLENBQUMsUUFBbUMsRUFBRSxRQUFnQjtRQUN0RixRQUFRLENBQUMsWUFBWSxDQUFDLFFBQVEsRUFBRSxRQUFRLEVBQUUsZUFBZSxDQUFDLENBQUM7SUFDN0QsQ0FBQztJQUVEOzs7O09BSUc7SUFDSSxNQUFNLENBQUMsb0JBQW9CLENBQ2hDLFFBQWdCLEVBQ2hCLE9BQTZCO1FBRTdCLE9BQU8sUUFBUSxDQUFDLFlBQVksQ0FBQyxRQUFRLEVBQUUsZUFBZSxFQUFFLFFBQVEsQ0FBQyxvQkFBb0IsRUFBRSxPQUFPLENBQUMsQ0FBQztJQUNsRyxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSSxNQUFNLENBQUMsaUJBQWlCLENBQUMsUUFBOEIsRUFBRSxRQUFnQjtRQUM5RSxRQUFRLENBQUMsWUFBWSxDQUFDLFFBQVEsRUFBRSxRQUFRLEVBQUUsYUFBYSxDQUFDLENBQUM7SUFDM0QsQ0FBQztJQUVEOzs7O09BSUc7SUFDSSxNQUFNLENBQUMsaUJBQWlCLENBQUMsUUFBZ0I7UUFDOUMsT0FBTyxRQUFRLENBQUMsWUFBWSxDQUFDLFFBQVEsRUFBRSxhQUFhLENBQUMsQ0FBQztJQUN4RCxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSSxNQUFNLENBQUMsaUJBQWlCLENBQUMsUUFBNkIsRUFBRSxRQUFnQjtRQUM3RSxRQUFRLENBQUMsWUFBWSxDQUFDLFFBQVEsRUFBRSxRQUFRLEVBQUUsWUFBWSxDQUFDLENBQUM7SUFDMUQsQ0FBQztJQUVEOzs7O09BSUc7SUFDSSxNQUFNLENBQUMsaUJBQWlCLENBQUMsUUFBZ0I7UUFDOUMsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxRQUFRLEVBQUUsWUFBWSxDQUFDLENBQUM7UUFFM0QsMEVBQTBFO1FBQzFFLGdFQUFnRTtRQUNoRSx1RUFBdUU7UUFDdkUsdUVBQXVFO1FBQ3ZFLGlGQUFpRjtRQUNqRixPQUFPO1lBQ0wsR0FBRyxRQUFRO1lBQ1gsU0FBUyxFQUFHLFFBQWdCLENBQUMsU0FBUyxJQUFJLEVBQUU7U0FDN0MsQ0FBQztJQUNKLENBQUM7SUFFRDs7T0FFRztJQUNJLE1BQU0sQ0FBQyxPQUFPO1FBQ25CLE9BQU8sR0FBRyxjQUFjLENBQUMsUUFBUSxNQUFNLENBQUM7SUFDMUMsQ0FBQztJQUVEOztPQUVHO0lBQ0ksTUFBTSxDQUFDLFVBQVU7UUFDdEIsTUFBTSxPQUFPLEdBQUcsV0FBVyxDQUFDLE9BQU8sQ0FBQztRQUNwQyxPQUFPLE9BQU8sQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUM7SUFDdkMsQ0FBQztJQUVEOzs7T0FHRztJQUNJLE1BQU0sQ0FBQyxJQUFJLENBQUMsUUFBbUMsRUFBRSxRQUFnQjtRQUN0RSxPQUFPLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxRQUFRLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFDdkQsQ0FBQztJQUVEOzs7T0FHRztJQUNJLE1BQU0sQ0FBQyxJQUFJLENBQUMsUUFBZ0I7UUFDakMsT0FBTyxJQUFJLENBQUMsb0JBQW9CLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDN0MsQ0FBQztJQUVPLE1BQU0sQ0FBQyxRQUFRLENBQ3JCLFFBQWEsRUFDYixNQUF5QixFQUN6QixPQUE2QjtRQUU3QixTQUFTLFlBQVksQ0FBQyxPQUFlO1lBQ25DLE1BQU0sR0FBRyxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDbEMsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO2dCQUNULE1BQU0sSUFBSSxLQUFLLENBQUMsMkJBQTJCLE9BQU8sR0FBRyxDQUFDLENBQUM7WUFDekQsQ0FBQztZQUNELE9BQU8sR0FBRyxDQUFDO1FBQ2IsQ0FBQztRQUVELE1BQU0sWUFBWSxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDcEUsTUFBTSxNQUFNLEdBQUcsWUFBWSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUU5QyxxR0FBcUc7UUFDckcsSUFBSSxZQUFZLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxDQUFDO1lBQ3RFLG9HQUFvRztZQUNwRyxNQUFNLFVBQVUsR0FBSSxRQUFzQyxDQUFDLGlCQUFpQixDQUFDO1lBQzdFLElBQUksVUFBVSxHQUFHLEVBQUUsQ0FBQztZQUNwQixJQUFJLFVBQVUsRUFBRSxDQUFDO2dCQUNmLFVBQVUsR0FBRyxtQ0FBbUMsVUFBVSx5QkFBeUIsQ0FBQztZQUN0RixDQUFDO1lBRUQsb0ZBQW9GO1lBQ3BGLDJDQUEyQztZQUMzQyxNQUFNLElBQUksS0FBSyxDQUNiLEdBQUcsd0JBQWdCLHlDQUF5QyxZQUFZLG1CQUFtQixNQUFNLEdBQUcsVUFBVSxFQUFFLENBQ2pILENBQUM7UUFDSixDQUFDO1FBRUQsbUNBQW1DO1FBQ25DLE1BQU0sU0FBUyxHQUFHLElBQUksVUFBVSxDQUFDLFNBQVMsRUFBRSxDQUFDO1FBQzdDLE1BQU0sTUFBTSxHQUFHLFNBQVMsQ0FBQyxRQUFRLENBQUMsUUFBUSxFQUFFLE1BQU0sRUFBRTtZQUNsRCxzREFBc0Q7WUFDdEQsWUFBWSxFQUFFLElBQUk7WUFFbEIsc0JBQXNCLEVBQUUsS0FBSztZQUM3QixtQkFBbUIsRUFBRSxRQUFRLENBQUMsbUNBQW1DO1NBQ2xFLENBQUMsQ0FBQztRQUVILElBQUksTUFBTSxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUM7UUFDM0IsSUFBSSxPQUFPLEVBQUUsYUFBYSxFQUFFLENBQUM7WUFDM0Isc0NBQXNDO1lBQ3RDLE1BQU0sR0FBRyxlQUFlLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDbkMsQ0FBQztRQUVELElBQUksTUFBTSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUUsQ0FBQztZQUN0QixNQUFNLElBQUksS0FBSyxDQUFDLCtCQUErQixNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUMxRixDQUFDO0lBQ0gsQ0FBQztJQUVPLE1BQU0sQ0FBQyxZQUFZLENBQ3pCLFFBQWEsRUFDYixRQUFnQixFQUNoQixNQUF5QixFQUN6QixVQUE4QjtRQUU5QixJQUFJLFdBQVcsR0FBRztZQUNoQixHQUFHLFFBQVE7WUFDWCxPQUFPLEVBQUUsUUFBUSxDQUFDLE9BQU8sRUFBRTtZQUMzQixpQkFBaUIsRUFBRSxRQUFRLENBQUMsVUFBVSxFQUFFO1NBQ0wsQ0FBQztRQUN0QyxRQUFRLENBQUMsUUFBUSxDQUFDLFdBQVcsRUFBRSxNQUFNLENBQUMsQ0FBQztRQUN2QyxJQUFJLFVBQVUsRUFBRSxDQUFDO1lBQ2YsV0FBVyxHQUFHLFVBQVUsQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUN4QyxDQUFDO1FBQ0QsRUFBRSxDQUFDLGFBQWEsQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxXQUFXLEVBQUUsU0FBUyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDeEUsQ0FBQztJQUVPLE1BQU0sQ0FBQyxZQUFZLENBQ3pCLFFBQWdCLEVBQ2hCLE1BQXlCLEVBQ3pCLFVBQThCLEVBQzlCLE9BQTZCO1FBRTdCLE1BQU0sUUFBUSxHQUFHLEVBQUUsQ0FBQyxZQUFZLENBQUMsUUFBUSxFQUFFLEVBQUUsUUFBUSxFQUFFLE9BQU8sRUFBRSxDQUFDLENBQUM7UUFDbEUsSUFBSSxHQUFHLENBQUM7UUFDUixJQUFJLENBQUM7WUFDSCxHQUFHLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUM3QixDQUFDO1FBQUMsT0FBTyxDQUFNLEVBQUUsQ0FBQztZQUNoQixNQUFNLElBQUksS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLE9BQU8sbUJBQW1CLElBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQzdFLENBQUM7UUFDRCxJQUFJLFVBQVUsRUFBRSxDQUFDO1lBQ2YsR0FBRyxHQUFHLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUN4QixDQUFDO1FBQ0QsUUFBUSxDQUFDLFFBQVEsQ0FBQyxHQUFHLEVBQUUsTUFBTSxFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBQ3hDLE9BQU8sR0FBRyxDQUFDO0lBQ2IsQ0FBQztJQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0F3Qkc7SUFDSyxNQUFNLENBQUMsb0JBQW9CLENBQWEsUUFBbUM7UUFDakYsTUFBTSxTQUFTLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsU0FBUyxJQUFJLEVBQUUsQ0FBQzthQUN0RCxNQUFNLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsSUFBSSxLQUFLLFFBQVEsQ0FBQyxZQUFZLENBQUMsd0JBQXdCLENBQUMsQ0FBQztRQUV4RixLQUFLLE1BQU0sUUFBUSxJQUFJLFNBQVMsRUFBRSxDQUFDO1lBQ2pDLE1BQU0sV0FBVyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLFFBQVEsSUFBSSxFQUFFLENBQUM7aUJBQ3ZELE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztpQkFDZixNQUFNLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxLQUFLLFFBQVEsQ0FBQyx5QkFBeUIsQ0FBQyxVQUFVLENBQUMsQ0FBQztZQUVqRixLQUFLLE1BQU0sS0FBSyxJQUFJLFdBQVcsRUFBRSxDQUFDO2dCQUNoQyxNQUFNLElBQUksR0FBRyxLQUFLLENBQUMsSUFBZ0UsQ0FBQztnQkFDcEYsS0FBSyxNQUFNLEdBQUcsSUFBSSxJQUFJLElBQUksRUFBRSxFQUFFLENBQUM7b0JBQzdCLE1BQU0sQ0FBQyxHQUFRLEdBQUcsQ0FBQztvQkFDbkIsSUFBSSxLQUFLLElBQUksQ0FBQyxFQUFFLENBQUM7d0JBQ2YsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDO3dCQUNkLE9BQU8sQ0FBQyxDQUFDLEdBQUcsQ0FBQztvQkFDZixDQUFDO29CQUNELElBQUksT0FBTyxJQUFJLENBQUMsRUFBRSxDQUFDO3dCQUNqQixDQUFDLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUM7d0JBQ2xCLE9BQU8sQ0FBQyxDQUFDLEtBQUssQ0FBQztvQkFDakIsQ0FBQztnQkFDSCxDQUFDO1lBQ0gsQ0FBQztRQUNILENBQUM7UUFFRCxPQUFPLFFBQVEsQ0FBQztJQUNsQixDQUFDO0lBRUQ7OztPQUdHO0lBQ0ssTUFBTSxDQUFDLG1DQUFtQyxDQUVoRCxRQUFhLEVBQ2IsR0FBVyxFQUNYLE9BQTBCLEVBQzFCLFFBQTRCLEVBQzVCLElBQThCO1FBRTlCLElBQUksR0FBRyxLQUFLLDZCQUE2QixFQUFFLENBQUM7WUFDMUMsc0ZBQXNGO1lBQ3RGLGdIQUFnSDtZQUNoSCw0R0FBNEc7WUFDNUcsZ0RBQWdEO1lBQ2hELE9BQU87UUFDVCxDQUFDO1FBRUQsTUFBTSxpQkFBaUIsR0FBRyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDeEMsSUFBSSxpQkFBaUIsRUFBRSxPQUFPLEVBQUUsQ0FBQztZQUMvQixNQUFNLElBQUksS0FBSyxDQUFDLGtDQUFrQyxHQUFHLEdBQUcsQ0FBQyxDQUFDO1FBQzVELENBQUM7UUFDRCxJQUFJLGlCQUFpQixFQUFFLFVBQVUsRUFBRSxDQUFDO1lBQ2xDLE1BQU0sSUFBSSxLQUFLLENBQUMscUNBQXFDLEdBQUcsR0FBRyxDQUFDLENBQUM7UUFDL0QsQ0FBQztJQUNILENBQUM7O0FBalJILDRCQWtSQzs7O0FBRUQsU0FBUyxlQUFlLENBQUMsTUFBb0M7SUFDM0QsT0FBTyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxNQUFNLEtBQUssUUFBUSxJQUFJLENBQUMsQ0FBQyxNQUFNLElBQUksQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7QUFDckYsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzJztcbmltcG9ydCAqIGFzIGpzb25zY2hlbWEgZnJvbSAnanNvbnNjaGVtYSc7XG5pbXBvcnQgKiBhcyBzZW12ZXIgZnJvbSAnc2VtdmVyJztcbmltcG9ydCB0eXBlICogYXMgYXNzZXRzIGZyb20gJy4vYXNzZXRzJztcbmltcG9ydCAqIGFzIGFzc2VtYmx5IGZyb20gJy4vY2xvdWQtYXNzZW1ibHknO1xuaW1wb3J0IHR5cGUgKiBhcyBpbnRlZyBmcm9tICcuL2ludGVnLXRlc3RzJztcblxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXZhci1yZXF1aXJlcyAqL1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0cyAqL1xuXG4vLyB0aGlzIHByZWZpeCBpcyB1c2VkIGJ5IHRoZSBDTEkgdG8gaWRlbnRpZnkgdGhpcyBzcGVjaWZpYyBlcnJvci5cbi8vIGluIHdoaWNoIGNhc2Ugd2Ugd2FudCB0byBpbnN0cnVjdCB0aGUgdXNlciB0byB1cGdyYWRlIGhpcyBDTEkuXG4vLyBzZWUgZXhlYy50cyNjcmVhdGVBc3NlbWJseVxuZXhwb3J0IGNvbnN0IFZFUlNJT05fTUlTTUFUQ0g6IHN0cmluZyA9ICdDbG91ZCBhc3NlbWJseSBzY2hlbWEgdmVyc2lvbiBtaXNtYXRjaCc7XG5cbi8qKlxuICogQ0xJIHZlcnNpb24gaXMgY3JlYXRlZCBhdCBidWlsZCBhbmQgcmVsZWFzZSB0aW1lXG4gKlxuICogSXQgbmVlZHMgdG8gYmUgLmdpdGlnbm9yZSdkLCBvdGhlcndpc2UgdGhlIHByb2plbiAnbm8gdW5jb21taXR0ZWRcbiAqIGNoYW5nZXMnIHNlbGYtY2hlY2sgd2lsbCBmYWlsLCB3aGljaCBtZWFucyBpdCBuZWVkcyB0byBiZSBnZW5lcmF0ZWRcbiAqIGF0IGJ1aWxkIHRpbWUgaWYgaXQgZG9lc24ndCBhbHJlYWR5IGV4aXN0LlxuICovXG5pbXBvcnQgQ0xJX1ZFUlNJT04gPSByZXF1aXJlKCcuLi9jbGktdmVyc2lvbi5qc29uJyk7XG5cbmltcG9ydCBBU1NFVFNfU0NIRU1BID0gcmVxdWlyZSgnLi4vc2NoZW1hL2Fzc2V0cy5zY2hlbWEuanNvbicpO1xuXG5pbXBvcnQgQVNTRU1CTFlfU0NIRU1BID0gcmVxdWlyZSgnLi4vc2NoZW1hL2Nsb3VkLWFzc2VtYmx5LnNjaGVtYS5qc29uJyk7XG5cbmltcG9ydCBJTlRFR19TQ0hFTUEgPSByZXF1aXJlKCcuLi9zY2hlbWEvaW50ZWcuc2NoZW1hLmpzb24nKTtcblxuLyoqXG4gKiBWZXJzaW9uIGlzIHNoYXJlZCBmb3IgYm90aCBtYW5pZmVzdHNcbiAqL1xuaW1wb3J0IFNDSEVNQV9WRVJTSU9OID0gcmVxdWlyZSgnLi4vc2NoZW1hL3ZlcnNpb24uanNvbicpO1xuXG4vKipcbiAqIE9wdGlvbnMgZm9yIHRoZSBsb2FkTWFuaWZlc3Qgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTG9hZE1hbmlmZXN0T3B0aW9ucyB7XG4gIC8qKlxuICAgKiBTa2lwIHRoZSB2ZXJzaW9uIGNoZWNrXG4gICAqXG4gICAqIFRoaXMgbWVhbnMgeW91IG1heSByZWFkIGEgbmV3ZXIgY2xvdWQgYXNzZW1ibHkgdGhhbiB0aGUgQ1ggQVBJIGlzIGRlc2lnbmVkXG4gICAqIHRvIHN1cHBvcnQsIGFuZCB5b3VyIGFwcGxpY2F0aW9uIG1heSBub3QgYmUgYXdhcmUgb2YgYWxsIGZlYXR1cmVzIHRoYXQgaW4gdXNlXG4gICAqIGluIHRoZSBDbG91ZCBBc3NlbWJseS5cbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHJlYWRvbmx5IHNraXBWZXJzaW9uQ2hlY2s/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBTa2lwIGVudW0gY2hlY2tzXG4gICAqXG4gICAqIFRoaXMgbWVhbnMgeW91IG1heSByZWFkIGVudW0gdmFsdWVzIHlvdSBkb24ndCBrbm93IGFib3V0IHlldC4gTWFrZSBzdXJlIHRvIGFsd2F5c1xuICAgKiBjaGVjayB0aGUgdmFsdWVzIG9mIGVudW1zIHlvdSBlbmNvdW50ZXIgaW4gdGhlIG1hbmlmZXN0LlxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgcmVhZG9ubHkgc2tpcEVudW1DaGVjaz86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFRvcG9sb2dpY2FsbHkgc29ydCBhbGwgYXJ0aWZhY3RzXG4gICAqXG4gICAqIFRoaXMgcGFyYW1ldGVyIGlzIG9ubHkgcmVzcGVjdGVkIGJ5IHRoZSBjb25zdHJ1Y3RvciBvZiBgQ2xvdWRBc3NlbWJseWAuIFRoZVxuICAgKiBwcm9wZXJ0eSBsaXZlcyBoZXJlIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSByZWFzb25zLlxuICAgKlxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICByZWFkb25seSB0b3BvU29ydD86IGJvb2xlYW47XG59XG5cbi8qKlxuICogUHJvdG9jb2wgdXRpbGl0eSBjbGFzcy5cbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIE1hbmlmZXN0IHtcbiAgLyoqXG4gICAqIFZhbGlkYXRlcyBhbmQgc2F2ZXMgdGhlIGNsb3VkIGFzc2VtYmx5IG1hbmlmZXN0IHRvIGZpbGUuXG4gICAqXG4gICAqIEBwYXJhbSBtYW5pZmVzdCAtIG1hbmlmZXN0LlxuICAgKiBAcGFyYW0gZmlsZVBhdGggLSBvdXRwdXQgZmlsZSBwYXRoLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBzYXZlQXNzZW1ibHlNYW5pZmVzdChtYW5pZmVzdDogYXNzZW1ibHkuQXNzZW1ibHlNYW5pZmVzdCwgZmlsZVBhdGg6IHN0cmluZykge1xuICAgIE1hbmlmZXN0LnNhdmVNYW5pZmVzdChtYW5pZmVzdCwgZmlsZVBhdGgsIEFTU0VNQkxZX1NDSEVNQSk7XG4gIH1cblxuICAvKipcbiAgICogTG9hZCBhbmQgdmFsaWRhdGVzIHRoZSBjbG91ZCBhc3NlbWJseSBtYW5pZmVzdCBmcm9tIGZpbGUuXG4gICAqXG4gICAqIEBwYXJhbSBmaWxlUGF0aCAtIHBhdGggdG8gdGhlIG1hbmlmZXN0IGZpbGUuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGxvYWRBc3NlbWJseU1hbmlmZXN0KFxuICAgIGZpbGVQYXRoOiBzdHJpbmcsXG4gICAgb3B0aW9ucz86IExvYWRNYW5pZmVzdE9wdGlvbnMsXG4gICk6IGFzc2VtYmx5LkFzc2VtYmx5TWFuaWZlc3Qge1xuICAgIHJldHVybiBNYW5pZmVzdC5sb2FkTWFuaWZlc3QoZmlsZVBhdGgsIEFTU0VNQkxZX1NDSEVNQSwgTWFuaWZlc3QucGF0Y2hTdGFja1RhZ3NPblJlYWQsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlcyBhbmQgc2F2ZXMgdGhlIGFzc2V0IG1hbmlmZXN0IHRvIGZpbGUuXG4gICAqXG4gICAqIEBwYXJhbSBtYW5pZmVzdCAtIG1hbmlmZXN0LlxuICAgKiBAcGFyYW0gZmlsZVBhdGggLSBvdXRwdXQgZmlsZSBwYXRoLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBzYXZlQXNzZXRNYW5pZmVzdChtYW5pZmVzdDogYXNzZXRzLkFzc2V0TWFuaWZlc3QsIGZpbGVQYXRoOiBzdHJpbmcpIHtcbiAgICBNYW5pZmVzdC5zYXZlTWFuaWZlc3QobWFuaWZlc3QsIGZpbGVQYXRoLCBBU1NFVFNfU0NIRU1BKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkIGFuZCB2YWxpZGF0ZXMgdGhlIGFzc2V0IG1hbmlmZXN0IGZyb20gZmlsZS5cbiAgICpcbiAgICogQHBhcmFtIGZpbGVQYXRoIC0gcGF0aCB0byB0aGUgbWFuaWZlc3QgZmlsZS5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbG9hZEFzc2V0TWFuaWZlc3QoZmlsZVBhdGg6IHN0cmluZyk6IGFzc2V0cy5Bc3NldE1hbmlmZXN0IHtcbiAgICByZXR1cm4gTWFuaWZlc3QubG9hZE1hbmlmZXN0KGZpbGVQYXRoLCBBU1NFVFNfU0NIRU1BKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgYW5kIHNhdmVzIHRoZSBpbnRlZyBtYW5pZmVzdCB0byBmaWxlLlxuICAgKlxuICAgKiBAcGFyYW0gbWFuaWZlc3QgLSBtYW5pZmVzdC5cbiAgICogQHBhcmFtIGZpbGVQYXRoIC0gb3V0cHV0IGZpbGUgcGF0aC5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgc2F2ZUludGVnTWFuaWZlc3QobWFuaWZlc3Q6IGludGVnLkludGVnTWFuaWZlc3QsIGZpbGVQYXRoOiBzdHJpbmcpIHtcbiAgICBNYW5pZmVzdC5zYXZlTWFuaWZlc3QobWFuaWZlc3QsIGZpbGVQYXRoLCBJTlRFR19TQ0hFTUEpO1xuICB9XG5cbiAgLyoqXG4gICAqIExvYWQgYW5kIHZhbGlkYXRlcyB0aGUgaW50ZWcgbWFuaWZlc3QgZnJvbSBmaWxlLlxuICAgKlxuICAgKiBAcGFyYW0gZmlsZVBhdGggLSBwYXRoIHRvIHRoZSBtYW5pZmVzdCBmaWxlLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBsb2FkSW50ZWdNYW5pZmVzdChmaWxlUGF0aDogc3RyaW5nKTogaW50ZWcuSW50ZWdNYW5pZmVzdCB7XG4gICAgY29uc3QgbWFuaWZlc3QgPSB0aGlzLmxvYWRNYW5pZmVzdChmaWxlUGF0aCwgSU5URUdfU0NIRU1BKTtcblxuICAgIC8vIEFkZGluZyB0eXBpbmcgdG8gYHZhbGlkYXRlKClgIGxlZCB0byBgbG9hZE1hbmlmZXN0KClgIHRvIHByb3Blcmx5IGluZmVyXG4gICAgLy8gaXRzIHJldHVybiB0eXBlLCB3aGljaCBpbmRpY2F0ZWQgdGhhdCB0aGUgcmV0dXJuIHR5cGUgb2YgdGhpc1xuICAgIC8vIGZ1bmN0aW9uIG1heSBiZSBhIGxpZS4gSSBjb3VsZCBjaGFuZ2UgdGhlIHNjaGVtYSB0byBtYWtlIGB0ZXN0Q2FzZXNgXG4gICAgLy8gb3B0aW9uYWwsIGJ1dCB0aGF0IHdpbGwgYnVtcCB0aGUgbWFqb3IgdmVyc2lvbiBvZiB0aGlzIHBhY2thZ2UgYW5kIElcbiAgICAvLyBkb24ndCB3YW50IHRvIGRvIHRoYXQuIFNvIGluc3RlYWQsIGp1c3QgbWFrZSBzdXJlIGB0ZXN0Q2FzZXNgIGlzIGFsd2F5cyB0aGVyZS5cbiAgICByZXR1cm4ge1xuICAgICAgLi4ubWFuaWZlc3QsXG4gICAgICB0ZXN0Q2FzZXM6IChtYW5pZmVzdCBhcyBhbnkpLnRlc3RDYXNlcyA/PyBbXSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBjdXJyZW50IHNjaGVtYSB2ZXJzaW9uIG51bWJlci5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgdmVyc2lvbigpOiBzdHJpbmcge1xuICAgIHJldHVybiBgJHtTQ0hFTUFfVkVSU0lPTi5yZXZpc2lvbn0uMC4wYDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIENMSSB2ZXJzaW9uIHRoYXQgc3VwcG9ydHMgdGhpcyBDbG91ZCBBc3NlbWJseSBTY2hlbWEgdmVyc2lvblxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBjbGlWZXJzaW9uKCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3QgdmVyc2lvbiA9IENMSV9WRVJTSU9OLnZlcnNpb247XG4gICAgcmV0dXJuIHZlcnNpb24gPyB2ZXJzaW9uIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcHJlY2F0ZWRcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGBzYXZlQXNzZW1ibHlNYW5pZmVzdCgpYFxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBzYXZlKG1hbmlmZXN0OiBhc3NlbWJseS5Bc3NlbWJseU1hbmlmZXN0LCBmaWxlUGF0aDogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMuc2F2ZUFzc2VtYmx5TWFuaWZlc3QobWFuaWZlc3QsIGZpbGVQYXRoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXByZWNhdGVkXG4gICAqIEBkZXByZWNhdGVkIHVzZSBgbG9hZEFzc2VtYmx5TWFuaWZlc3QoKWBcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbG9hZChmaWxlUGF0aDogc3RyaW5nKTogYXNzZW1ibHkuQXNzZW1ibHlNYW5pZmVzdCB7XG4gICAgcmV0dXJuIHRoaXMubG9hZEFzc2VtYmx5TWFuaWZlc3QoZmlsZVBhdGgpO1xuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgdmFsaWRhdGUoXG4gICAgbWFuaWZlc3Q6IGFueSxcbiAgICBzY2hlbWE6IGpzb25zY2hlbWEuU2NoZW1hLFxuICAgIG9wdGlvbnM/OiBMb2FkTWFuaWZlc3RPcHRpb25zLFxuICApOiBhc3NlcnRzIG1hbmlmZXN0IGlzIGFzc2VtYmx5LkFzc2VtYmx5TWFuaWZlc3Qge1xuICAgIGZ1bmN0aW9uIHBhcnNlVmVyc2lvbih2ZXJzaW9uOiBzdHJpbmcpIHtcbiAgICAgIGNvbnN0IHZlciA9IHNlbXZlci52YWxpZCh2ZXJzaW9uKTtcbiAgICAgIGlmICghdmVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzZW12ZXIgc3RyaW5nOiBcIiR7dmVyc2lvbn1cImApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZlcjtcbiAgICB9XG5cbiAgICBjb25zdCBtYXhTdXBwb3J0ZWQgPSBzZW12ZXIubWFqb3IocGFyc2VWZXJzaW9uKE1hbmlmZXN0LnZlcnNpb24oKSkpO1xuICAgIGNvbnN0IGFjdHVhbCA9IHBhcnNlVmVyc2lvbihtYW5pZmVzdC52ZXJzaW9uKTtcblxuICAgIC8vIGZpcnN0IHZhbGlkYXRlIHRoZSB2ZXJzaW9uIHNob3VsZCBiZSBhY2NlcHRlZC4gYWxsIHZlcnNpb25zIHdpdGhpbiB0aGUgc2FtZSBtaW5vciB2ZXJzaW9uIGFyZSBmaW5lXG4gICAgaWYgKG1heFN1cHBvcnRlZCA8IHNlbXZlci5tYWpvcihhY3R1YWwpICYmICFvcHRpb25zPy5za2lwVmVyc2lvbkNoZWNrKSB7XG4gICAgICAvLyBJZiB3ZSBoYXZlIGEgbW9yZSBzcGVjaWZpYyBlcnJvciB0byB0aHJvdyB0aGFuIHRoZSBnZW5lcmljIG9uZSBiZWxvdywgbWFrZSBzdXJlIHRvIGFkZCB0aGF0IGluZm8uXG4gICAgICBjb25zdCBjbGlWZXJzaW9uID0gKG1hbmlmZXN0IGFzIGFzc2VtYmx5LkFzc2VtYmx5TWFuaWZlc3QpLm1pbmltdW1DbGlWZXJzaW9uO1xuICAgICAgbGV0IGNsaVdhcm5pbmcgPSAnJztcbiAgICAgIGlmIChjbGlWZXJzaW9uKSB7XG4gICAgICAgIGNsaVdhcm5pbmcgPSBgLiBZb3UgbmVlZCBhdCBsZWFzdCBDTEkgdmVyc2lvbiAke2NsaVZlcnNpb259IHRvIHJlYWQgdGhpcyBtYW5pZmVzdC5gO1xuICAgICAgfVxuXG4gICAgICAvLyB3ZSB1c2UgYSB3ZWxsIGtub3duIGVycm9yIHByZWZpeCBzbyB0aGF0IHRoZSBDTEkgY2FuIGlkZW50aWZ5IHRoaXMgc3BlY2lmaWMgZXJyb3JcbiAgICAgIC8vIGFuZCBwcmludCBzb21lIG1vcmUgY29udGV4dCB0byB0aGUgdXNlci5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYCR7VkVSU0lPTl9NSVNNQVRDSH06IE1heGltdW0gc2NoZW1hIHZlcnNpb24gc3VwcG9ydGVkIGlzICR7bWF4U3VwcG9ydGVkfS54LngsIGJ1dCBmb3VuZCAke2FjdHVhbH0ke2NsaVdhcm5pbmd9YCxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gbm93IHZhbGlkYXRlIHRoZSBmb3JtYXQgaXMgZ29vZC5cbiAgICBjb25zdCB2YWxpZGF0b3IgPSBuZXcganNvbnNjaGVtYS5WYWxpZGF0b3IoKTtcbiAgICBjb25zdCByZXN1bHQgPSB2YWxpZGF0b3IudmFsaWRhdGUobWFuaWZlc3QsIHNjaGVtYSwge1xuICAgICAgLy8gZG9lcyBleGlzdCBidXQgaXMgbm90IGluIHRoZSBUeXBlU2NyaXB0IGRlZmluaXRpb25zXG4gICAgICBuZXN0ZWRFcnJvcnM6IHRydWUsXG5cbiAgICAgIGFsbG93VW5rbm93bkF0dHJpYnV0ZXM6IGZhbHNlLFxuICAgICAgcHJlVmFsaWRhdGVQcm9wZXJ0eTogTWFuaWZlc3QudmFsaWRhdGVBc3N1bWVSb2xlQWRkaXRpb25hbE9wdGlvbnMsXG4gICAgfSk7XG5cbiAgICBsZXQgZXJyb3JzID0gcmVzdWx0LmVycm9ycztcbiAgICBpZiAob3B0aW9ucz8uc2tpcEVudW1DaGVjaykge1xuICAgICAgLy8gRW51bSB2YWxpZGF0aW9ucyBhcmVuJ3QgdXNlZnVsIHdoZW5cbiAgICAgIGVycm9ycyA9IHN0cmlwRW51bUVycm9ycyhlcnJvcnMpO1xuICAgIH1cblxuICAgIGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGFzc2VtYmx5IG1hbmlmZXN0OlxcbiR7ZXJyb3JzLm1hcCgoZSkgPT4gZS5zdGFjaykuam9pbignXFxuJyl9YCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgc2F2ZU1hbmlmZXN0KFxuICAgIG1hbmlmZXN0OiBhbnksXG4gICAgZmlsZVBhdGg6IHN0cmluZyxcbiAgICBzY2hlbWE6IGpzb25zY2hlbWEuU2NoZW1hLFxuICAgIHByZXByb2Nlc3M/OiAob2JqOiBhbnkpID0+IGFueSxcbiAgKSB7XG4gICAgbGV0IHdpdGhWZXJzaW9uID0ge1xuICAgICAgLi4ubWFuaWZlc3QsXG4gICAgICB2ZXJzaW9uOiBNYW5pZmVzdC52ZXJzaW9uKCksXG4gICAgICBtaW5pbXVtQ2xpVmVyc2lvbjogTWFuaWZlc3QuY2xpVmVyc2lvbigpLFxuICAgIH0gc2F0aXNmaWVzIGFzc2VtYmx5LkFzc2VtYmx5TWFuaWZlc3Q7XG4gICAgTWFuaWZlc3QudmFsaWRhdGUod2l0aFZlcnNpb24sIHNjaGVtYSk7XG4gICAgaWYgKHByZXByb2Nlc3MpIHtcbiAgICAgIHdpdGhWZXJzaW9uID0gcHJlcHJvY2Vzcyh3aXRoVmVyc2lvbik7XG4gICAgfVxuICAgIGZzLndyaXRlRmlsZVN5bmMoZmlsZVBhdGgsIEpTT04uc3RyaW5naWZ5KHdpdGhWZXJzaW9uLCB1bmRlZmluZWQsIDIpKTtcbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIGxvYWRNYW5pZmVzdChcbiAgICBmaWxlUGF0aDogc3RyaW5nLFxuICAgIHNjaGVtYToganNvbnNjaGVtYS5TY2hlbWEsXG4gICAgcHJlcHJvY2Vzcz86IChvYmo6IGFueSkgPT4gYW55LFxuICAgIG9wdGlvbnM/OiBMb2FkTWFuaWZlc3RPcHRpb25zLFxuICApIHtcbiAgICBjb25zdCBjb250ZW50cyA9IGZzLnJlYWRGaWxlU3luYyhmaWxlUGF0aCwgeyBlbmNvZGluZzogJ3V0Zi04JyB9KTtcbiAgICBsZXQgb2JqO1xuICAgIHRyeSB7XG4gICAgICBvYmogPSBKU09OLnBhcnNlKGNvbnRlbnRzKTtcbiAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtlLm1lc3NhZ2V9LCB3aGlsZSBwYXJzaW5nICR7SlNPTi5zdHJpbmdpZnkoY29udGVudHMpfWApO1xuICAgIH1cbiAgICBpZiAocHJlcHJvY2Vzcykge1xuICAgICAgb2JqID0gcHJlcHJvY2VzcyhvYmopO1xuICAgIH1cbiAgICBNYW5pZmVzdC52YWxpZGF0ZShvYmosIHNjaGVtYSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaXggdGhlIGNhc2luZyBvZiBzdGFjayB0YWdzIGVudHJpZXNcbiAgICpcbiAgICogQXQgdGhlIHZlcnkgYmVnaW5uaW5nIG9mIHRoZSBDREsgd2UgdXNlZCB0byBlbWl0IHN0YWNrIHRhZ3MgYXMgYW4gb2JqZWN0IHdpdGhcbiAgICogYHsgS2V5LCBWYWx1ZSB9YCBrZXlzOyB0aGlzIGhhZCB0aGUgXCJhZHZhbnRhZ2VcIiB0aGF0IHdlIGNvdWxkIHN0aWNrIHRob3NlXG4gICAqIHRhZ3MgZGlyZWN0bHkgaW50byB0aGUgYENyZWF0ZUNoYW5nZVNldGAgY2FsbC5cbiAgICpcbiAgICogVGhlbiB3ZSBsYXRlciBvbiB1c2VkIGpzaWkgb24gdGhlIGFzc2VtYmx5IHNjaGVtYSBhbmQgd2Ugd2VyZSBmb3JjZWQgdG8gdHlwZVxuICAgKiB0aGUgaW4tbWVtb3J5IG9iamVjdHMgYXMgYHsga2V5LCB2YWx1ZSB9YCB3aXRoIGxvd2VyY2FzZSBsZXR0ZXJzLiBOb3cgdGhlXG4gICAqIG9iamVjdHMgaGF2ZSBhIGRpZmZlcmVudCBvbi1kaXNrIGFuZCBpbi1tZW1vcnkgZm9ybWF0LCBhbmQgd2UgbmVlZCB0byBjb252ZXJ0XG4gICAqIGJldHdlZW4gdGhlbS5cbiAgICpcbiAgICogRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHJlYXNvbnMsIHdlIHVzZWQgdG8gY29udmVydCBsb3dlcmNhc2UgaW4tbWVtb3J5XG4gICAqIHRvIHVwcGVyY2FzZSBvbi1kaXNrIHZhcmlhbnQgdW50aWwgdmVyeSByZWNlbnRseS4gVGhpcyBpcyBub3cgdW5uZWNlc3NhcnksXG4gICAqIHNpbmNlIG5vIG9mZmljaWFsbHkgc3VwcG9ydGVkIENESyB0b29scyByZWFkIHRoZSBzdGFjayB0YWdzIGZyb20gdGhlXG4gICAqIG1ldGFkYXRhOyB0aGUgQ0xJIGFuZCB0b29sa2l0IGxpYnJhcnkgcmVhZCBzdGFjayB0YWdzIGZyb20gdGhlIGFydGlmYWN0XG4gICAqIHByb3BlcnRpZXMuXG4gICAqXG4gICAqIFNvIGFsdGhvdWdoIHdlIGRvbid0IGVtaXQgdXBwZXJjYXNlIHN0YWNrIHRhZyBvYmplY3RzIGFueW1vcmUsIHdlIG1pZ2h0IHN0aWxsIHJlYWRcbiAgICogbWFuaWZlc3RzIHRoYXQgaGF2ZSB0aGVtLiBCZWNhdXNlIHRoZSBtYW5pZmVzdCB3ZSByZWFkIG11c3QgcGFzcyBKU09OIFNjaGVtYVxuICAgKiB2YWxpZGF0aW9uICh3aGljaCBleHBlY3RzIGxvd2VyY2FzZSB0YWcgb2JqZWN0cyksIHdlIGhhdmUgdG8gZml4IHRoZSBjYXNpbmdcbiAgICogb2YgdGhlc2Ugb2JqZWN0cyBhZnRlciByZWFkaW5nIGZyb20gZGlzayBhbmQgYmVmb3JlIHZhbGlkYXRpbmcuXG4gICAqXG4gICAqIFRoYXQncyB3aGF0IHRoaXMgZnVuY3Rpb24gZG9lcy5cbiAgICovXG4gIHByaXZhdGUgc3RhdGljIHBhdGNoU3RhY2tUYWdzT25SZWFkKHRoaXM6IHZvaWQsIG1hbmlmZXN0OiBhc3NlbWJseS5Bc3NlbWJseU1hbmlmZXN0KSB7XG4gICAgY29uc3QgYXJ0aWZhY3RzID0gT2JqZWN0LnZhbHVlcyhtYW5pZmVzdC5hcnRpZmFjdHMgPz8ge30pXG4gICAgICAuZmlsdGVyKGFydGlmYWN0ID0+IGFydGlmYWN0LnR5cGUgPT09IGFzc2VtYmx5LkFydGlmYWN0VHlwZS5BV1NfQ0xPVURGT1JNQVRJT05fU1RBQ0spO1xuXG4gICAgZm9yIChjb25zdCBhcnRpZmFjdCBvZiBhcnRpZmFjdHMpIHtcbiAgICAgIGNvbnN0IHRhZ01ldGFkYXRhID0gT2JqZWN0LnZhbHVlcyhhcnRpZmFjdC5tZXRhZGF0YSA/PyB7fSlcbiAgICAgICAgLmZsYXRNYXAoeCA9PiB4KVxuICAgICAgICAuZmlsdGVyKGVudHJ5ID0+IGVudHJ5LnR5cGUgPT09IGFzc2VtYmx5LkFydGlmYWN0TWV0YWRhdGFFbnRyeVR5cGUuU1RBQ0tfVEFHUyk7XG5cbiAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgdGFnTWV0YWRhdGEpIHtcbiAgICAgICAgY29uc3QgdGFncyA9IGVudHJ5LmRhdGEgYXMgdW5rbm93biBhcyBhc3NlbWJseS5TdGFja1RhZ3NNZXRhZGF0YUVudHJ5W10gfCB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3QgdGFnIG9mIHRhZ3MgPz8gW10pIHtcbiAgICAgICAgICBjb25zdCB0OiBhbnkgPSB0YWc7XG4gICAgICAgICAgaWYgKCdLZXknIGluIHQpIHtcbiAgICAgICAgICAgIHQua2V5ID0gdC5LZXk7XG4gICAgICAgICAgICBkZWxldGUgdC5LZXk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgnVmFsdWUnIGluIHQpIHtcbiAgICAgICAgICAgIHQudmFsdWUgPSB0LlZhbHVlO1xuICAgICAgICAgICAgZGVsZXRlIHQuVmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hbmlmZXN0O1xuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlcyB0aGF0IGBhc3N1bWVSb2xlQWRkaXRpb25hbE9wdGlvbnNgIGRvZXNuJ3QgY29udGFpbiBub3IgYEV4dGVybmFsSWRgIG5laXRoZXIgYFJvbGVBcm5gLCBhcyB0aGV5XG4gICAqIHNob3VsZCBoYXZlIGRlZGljYXRlZCBwcm9wZXJ0aWVzIHByZWNlZGluZyB0aGlzIChlLmcgYGFzc3VtZVJvbGVBcm5gIGFuZCBgYXNzdW1lUm9sZUV4dGVybmFsSWRgKS5cbiAgICovXG4gIHByaXZhdGUgc3RhdGljIHZhbGlkYXRlQXNzdW1lUm9sZUFkZGl0aW9uYWxPcHRpb25zKFxuICAgIHRoaXM6IHZvaWQsXG4gICAgaW5zdGFuY2U6IGFueSxcbiAgICBrZXk6IHN0cmluZyxcbiAgICBfc2NoZW1hOiBqc29uc2NoZW1hLlNjaGVtYSxcbiAgICBfb3B0aW9uczoganNvbnNjaGVtYS5PcHRpb25zLFxuICAgIF9jdHg6IGpzb25zY2hlbWEuU2NoZW1hQ29udGV4dCxcbiAgKSB7XG4gICAgaWYgKGtleSAhPT0gJ2Fzc3VtZVJvbGVBZGRpdGlvbmFsT3B0aW9ucycpIHtcbiAgICAgIC8vIG5vdGUgdGhhdCB0aGlzIG1lYW5zIHRoYXQgaWYgd2UgaGFwcGVuIHRvIGhhdmUgYSBwcm9wZXJ0eSBuYW1lZCBsaWtlIHRoaXMsIGJ1dCB0aGF0XG4gICAgICAvLyBkb2VzIHdhbnQgdG8gYWxsb3cgJ1JvbGVBcm4nIG9yICdFeHRlcm5hbElkJywgdGhpcyBjb2RlIHdpbGwgaGF2ZSB0byBjaGFuZ2UgdG8gY29uc2lkZXIgdGhlIGZ1bGwgc2NoZW1hIHBhdGguXG4gICAgICAvLyBJIGRlY2lkZWQgdG8gbWFrZSB0aGlzIGxlc3MgZ3JhbnVsYXIgZm9yIG5vdyBvbiBwdXJwb3NlIGJlY2F1c2UgaXQgZml0cyBvdXIgbmVlZHMgYW5kIGF2b2lkcyBoYXZpbmcgbWVzc3lcbiAgICAgIC8vIHZhbGlkYXRpb24gbG9naWMgZHVlIHRvIHZhcmlvdXMgc2NoZW1hIHBhdGhzLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGFzc3VtZVJvbGVPcHRpb25zID0gaW5zdGFuY2Vba2V5XTtcbiAgICBpZiAoYXNzdW1lUm9sZU9wdGlvbnM/LlJvbGVBcm4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUm9sZUFybiBpcyBub3QgYWxsb3dlZCBpbnNpZGUgJyR7a2V5fSdgKTtcbiAgICB9XG4gICAgaWYgKGFzc3VtZVJvbGVPcHRpb25zPy5FeHRlcm5hbElkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4dGVybmFsSWQgaXMgbm90IGFsbG93ZWQgaW5zaWRlICcke2tleX0nYCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0cmlwRW51bUVycm9ycyhlcnJvcnM6IGpzb25zY2hlbWEuVmFsaWRhdGlvbkVycm9yW10pIHtcbiAgcmV0dXJuIGVycm9ycy5maWx0ZXIoKGUpID0+IHR5cGVvZiBlLnNjaGVtYSA9PT0gJ3N0cmluZycgfHwgISgnZW51bScgaW4gZS5zY2hlbWEpKTtcbn1cbiJdfQ==